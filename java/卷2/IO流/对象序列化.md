#### 写入和读取序列化对象
要保存和读取对象数据，需要使用`ObjectOutputStream`和`ObjectInputStream`类
```java
var out = new ObjectOutputStream(new FileOutputStream("test"));
var in = new ObjectInputStream(new FileInputStream("test"))
```
通过`writeObject`和`readObject`方法来读写流。
对于要存储和读取的对象，需要使类**可序列化**，需要实现一个空的标记接口==Serializable==。

`ObjectOutputStream`会浏览对象的所有域并存储它们的内容。每个对象都是用一个**序列号**保存的。
在保存序列化对象时，对象的属性可能会有引用类型，当然不能保存它们的地址。因为对象被重新加载时，它大概率会使用与原来完全不同的地址。
##### 对象序列化的算法
1. 对输入的每一个对象都关联一个序列号
2. 对于每个对象：第一次保存时，将数据输出到输出流中；否则，只需要向流输入一个序列号作为指向即可。
3. 对于对象输入流：在第一次加载某个序列号时，使用流中数据来构建并初始化它，然后记录这个序列号和新对象之间的引用；否则，直接获取之前加载过的对象引用即可
#### 修改默认的序列化机制
有些实例域不应该被序列化，存储它们没有作用。例如：只对本地方法有用的存储文件句柄或窗口句柄，这些不需要序列化。
Java有一种机制用来防止域被序列化：**标记==transient==**
>如果一个可序列化的类的父类是`transient`的，那么父类必须有一个可访问的无参构造器。这样在序列化子类时，子类内部继承的父类会用无参构造器来构造。
##### 默认序列化机制方法
类在被序列化输出读取时，会调用序列化方法来自动序列化。但是可以通过重载来自定义默认读写行为：
```java
//@Serial注解表示要对序列化方法做重载检查
@Serial private void readObject(ObjectInputStream in) throws IOException,ClassNotFoundException;
@Serial private void writeObject(ObjectOutputStream out) throws IOException;
```
`ObjectInput/OutputStream`类中各有一个特殊的方法：`defaultWriteObject`和`defaultReadObject`，表示调用默认的读写行为。
>自定义读写行为可以序列化`transient`的对象内部的可序列化对象

#### Externalizable接口
除了序列化机制，类可以定义它自己的序列化机制。需要实现`Externalizable`接口：
```java
public void readExternal(ObjectInput in) throws IOException,ClassNotFoundException;
public void writeExternal(ObjectOutput out) throws IOException;
```
与默认的序列化机制不同，这些方法对包括**父类数据**在内的对象的序列化负责。
在写入对象时，默认序列化在输出流中只记录该对象所属的类。在读取**可外部化**的类时，对象输入流将用无参构造器创建一个对象，然后调用`readExternal`方法
>与默认序列化机制方法不同，该接口实现的方法是`public`的。
>不能修改枚举和记录的序列化。

### readResolve和writeReplace
在序列化和反序列化时，对象ID会造成`readObject()`返回的对象与之前写入的对象不是一个对象。
```java
@Serial private Object readResolve() throws ObjectStreamException;
@Serial private
```
#### readResolve
在对象被序列化后会调用该方法。该方法会返回一个对象，该对象会成为`readObject`方法的返回值。
针对对象ID不同，可以通过该方法检查实例的内容，如果一致就返回源对象来确保ID一致。
>粗浅的将该方法理解为：改变读取时构造的对象