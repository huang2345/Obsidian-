#### 创建并行流
可以用集合的`parallelStream()`方法获取一个并行流，也可以对顺序流使用`parallel()`方法将顺序流转换为并行流。只要在终结操作执行时流处于并行模式，所有的中间流操作都将并行。
#### 排序处理
默认情况下，从有序集合、范围、生成器和迭代器产生的流，或者调用`Stream.sorted`产生的流，都是==有序的==。
排序并不排斥高效的并行处理。例如：`stream.map(func)`时，流被划分为n部分，它们会并行处理。然后，结果按照顺序重新组装。

可以通过`unordered()`来放弃排序。放弃排序可以使得某些操作更有效地并行化，例如：`distinct()`、`limit`
在有序流中，`distinct()`会保留所有相同元素的第一个，这会降低并行时的效率。
#### 使用并行流的意义
1. 并行化会导致大量的开销，只在大的数据集才划算
2. 只有在底层的数据源可以被有效分割成多个部分时，并行流才有意义
3. 并行流使用的线程池可能会因诸如文件I/O或网络访问这样的操作被阻塞
>默认情况下，并行流使用的是`ForkJoinPool.commonPool`返回的全局`fork-join`池。
>只有在操作不会阻塞并且开发者不对这个池提交任务的情况下，这种方式不会有什么问题。
>如果出现了阻塞等问题，可以将操作放置到其他池中作为任务提交