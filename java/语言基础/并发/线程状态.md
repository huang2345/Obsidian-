- New(新建)
- Runnable(可运行)
- Blocked(阻塞)
- Waiting(等待)
- Timed waiting(计时等待)
- Terminated(终止)
可以通过`getState`方法获取一个线程的当前状态。
#### 新建
线程对象在创建后没有调用`start`时。
#### 可运行
调用`start`方法后，线程就处于该状态。可运行状态的线程可能正在运行也可能没有运行。

事实上，运行中的线程并不是一直在运行，线程调度的细节依赖于操作系统提供的服务。抢占式调度系统会给每一个可运行线程一个时间片来执行任务，当时间片用完时，操作系统会剥夺该线程的运行权，切换为其他线程。选择其他线程时，会先运行优先级高的线程。
所有PC和服务器操作系统都使用抢占式调度系统，但像手机这种小型设备可能使用协作式调度，在这种设备中，只有线程调用静态方法`Thread.yield`或被阻塞或等待时才会失去控制权。
#### 阻塞和等待
当线程处于阻塞或等待状态时，它暂时是不活动的。它不执行任何代码，并且消耗资源最少。要由**线程调度器**重新激活这个线程。
![](Pasted%20image%2020241006200523.png)
#### 终止线程
线程会由于以下原因之一而终止：
- 由于`run`方法正常退出，自然终止
- 因为一个没有捕获的异常终止了`run`方法，线程意外终止。
可以调用线程的`stop`方法终止一个线程，该方法抛出一个`ThreadDeath`。但是该方法已经废弃，不要使用它。New(新建)
- Runnable(可运行)
- Blocked(阻塞)
- Waiting(等待)
- Timed waiting(计时等待)
- Terminated(终止)
可以通过`getState`方法获取一个线程的当前状态。
#### 新建
线程对象在创建后没有调用`start`时。
#### 可运行
调用`start`方法后，线程就处于该状态。可运行状态的线程可能正在运行也可能没有运行。

事实上，运行中的线程并不是一直在运行，线程调度的细节依赖于操作系统提供的服务。抢占式调度系统会给每一个可运行线程一个时间片来执行任务，当时间片用完时，操作系统会剥夺该线程的运行权，切换为其他线程。选择其他线程时，会先运行优先级高的线程。
所有PC和服务器操作系统都使用抢占式调度系统，但像手机这种小型设备可能使用协作式调度，在这种设备中，只有线程调用静态方法`Thread.yield`或被阻塞或等待时才会失去控制权。
#### 阻塞和等待
当线程处于阻塞或等待状态时，它暂时是不活动的。它不执行任何代码，并且消耗资源最少。要由**线程调度器**重新激活这个线程。
![](Pasted%20image%2020241006200523.png)
#### 终止线程
线程会由于以下原因之一而终止：
- 由于`run`方法正常退出，自然终止
- 因为一个没有捕获的异常终止了`run`方法，线程意外终止。
可以调用线程的`stop`方法终止一个线程，该方法抛出一个`ThreadDeath`。但是该方法已经废弃，不要使用它。