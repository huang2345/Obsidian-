在大多数情况下，线程之间需要共享相同的数据。而线程同时访问同一个对象的情况被称为**竟态条件**。
#### 竟态条件例子解析
线程更新一个数组的元素，该指令可能如下处理：
1. 将数组元素加载到寄存器
2. 更新
3. 将结果写入当对应的地址

---
但如果出现竟台条件，1号线程可能执行完第二步后运行权被抢占，再假设此时2号线程被唤醒，更新了同一个数组元素。然后1号线程被唤醒，完成第三步。
这样一来，1号线程的第三步会抹去2号线程的修改。
### 锁对象
Java有两种机制可防止竟态条件，`synchronized`关键字和`ReentrantLock`类。
#### ReentrantLock类
基本结构如下：
```java
private Lock lock = new ReentrantLock();
//锁定锁对象
lock.lock();
try{
	...
}finally{
	//释放锁
	lock.unlock();
}
```
这确保同一时间只有一个线程可以访问`try...finally`语句块的内容。一旦某个线程锁定了锁对象，其他线程调用`lock`方法时，该线程会被阻塞，直到该锁被释放
##### 重入锁
线程可以反复获得已拥有的锁。锁有一个**持有计数**来跟踪对`lock`方法的嵌套调用。
例如：由锁保护的代码块调用`test`方法，而`test`方法同样获取了这个锁，此时会增加锁对象的持有计数(应当为2)。每次调用`unlock`方法持有计数会减1，当持有技术为0时，线程释放锁。
#### 条件对象
有时，线程进入临界区后却发现需要满足某个条件之后它才能执行。这种情况往往是在等待其他线程完成一些操作。
>临界区：被锁保护的代码块

但是，在满足条件之前，线程需要等待。并且，该线程拥有的锁对象可能是其他线程需要的，而这个其他线程可能就是那个去满足条件的线程。这时，就需要使用**条件对象**去暂停线程并放弃相关联的锁。
```java
//通过线程对象的newCondition方法获取相关联的条件对象
private Condition a = lock.newCondition();
...
//暂停线程并放弃锁
a.await();
```
等待获得锁的线程和调用了`await`方法的线程有本质上的不同。调用了`await`方法的线程会进入这个条件的**等待集**。当锁可用时，该线程不会变为可运行状态，它仍保持非活动状态，直到其他线程调用这个条件对象的`signalAll`方法。
```java
//其他线程完成操作后
//解除等待的所有线程的阻塞
xxx.signalAll()
...
//随机解除等待集中的某一个线程的阻塞
xxx.signal()
```
`signalAll`方法会解除等待这个条件的所有线程的阻塞。这些线程会从等待集移出，再次变为可运行状态，调度器最终将他们再次激活。一旦锁可用，它们中的某个线程将从`await`调用返回，得到锁的同时从之前暂停的地方继续执行。
>被重新激活的线程，应当重新测试条件是否满足。通常，`await`调用应该被放在：
>`while(条件){xxx.await()}`，以保证重新激活后条件满足

除了`signalAll`方法外，还有`signal`方法。`signal`方法更高效，但也存在风险。如果随机选择的线程发现自己依旧没有满足条件，该线程就会再次阻塞。如果没有其他线程再次调用`signal`，程序将会陷入死锁。