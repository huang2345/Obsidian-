在大多数情况下，线程之间需要共享相同的数据。而线程同时访问同一个对象的情况被称为**竟态条件**。
#### 竟态条件例子解析
线程更新一个数组的元素，该指令可能如下处理：
1. 将数组元素加载到寄存器
2. 更新
3. 将结果写入当对应的地址

---
但如果出现竟台条件，1号线程可能执行完第二步后运行权被抢占，再假设此时2号线程被唤醒，更新了同一个数组元素。然后1号线程被唤醒，完成第三步。
这样一来，1号线程的第三步会抹去2号线程的修改。
### 锁对象
Java有两种机制可防止竟态条件，`synchronized`关键字和`ReentrantLock`类。
#### ReentrantLock类
基本结构如下：
```java
private Lock lock = new ReentrantLock();
//锁定锁对象
lock.lock();
try{
	...
}finally{
	//释放锁
	lock.unlock();
}
```
这确保同一时间只有一个线程可以访问`try...finally`语句块的内容。一旦某个线程锁定了锁对象，其他线程调用`lock`方法时，该线程会被阻塞，直到该锁被释放
##### 重入锁
线程可以反复获得已拥有的锁。锁有一个**持有计数**来跟踪对`lock`方法的嵌套调用。
例如：由锁保护的代码块调用`test`方法，而`test`方法同样获取了这个锁，此时会增加锁对象的持有计数(应当为2)。每次调用`unlock`方法持有计数会减1，当持有技术为0时，线程释放锁。
#### 条件对象
有时，线程进入临界区后却发现需要满足某个条件之后它才能执行。这种情况往往是在等待其他线程完成一些操作。
>临界区：被锁保护的代码块

但是，在满足条件之前，线程需要等待。并且，该线程拥有的锁对象可能是其他线程需要的，而这个其他线程可能就是那个去满足条件的线程。这时，就需要使用**条件对象**去暂停线程并放弃相关联的锁。
```java
//通过线程对象的newCondition方法获取相关联的条件对象
private Condition a = lock.newCondition();
...
//暂停线程并放弃锁
a.await();
```
等待获得锁的线程和调用了`await`方法的线程有本质上的不同。调用了`await`方法的线程会进入这个条件的**等待集**。当锁可用时，该线程不会变为可运行状态，它仍保持非活动状态，直到其他线程调用这个条件对象的`signalAll`方法。
```java
//其他线程完成操作后
//解除等待的所有线程的阻塞
xxx.signalAll()
...
//随机解除等待集中的某一个线程的阻塞
xxx.signal()
```
`signalAll`方法会解除等待这个条件的所有线程的阻塞。这些线程会从等待集移出，再次变为可运行状态，调度器最终将他们再次激活。一旦锁可用，它们中的某个线程将从`await`调用返回，得到锁的同时从之前暂停的地方继续执行。
>被重新激活的线程，应当重新测试条件是否满足。通常，`await`调用应该被放在：
>`while(条件){xxx.await()}`，以保证重新激活后条件满足

除了`signalAll`方法外，还有`signal`方法。`signal`方法更高效，但也存在风险。如果随机选择的线程发现自己依旧没有满足条件，该线程就会再次阻塞。如果没有其他线程再次调用`signal`，程序将会陷入死锁。
#### synchronized关键字
`Lock`和`Condition`接口允许开发者充分控制锁。但是，大多数情况下并不需要这种强力的控制。从Java1.0开始，Java中的每个对象都有一个内部锁，对方法使用`synchronized`关键字将使用这个内部锁。内部对象锁只有一个关联条件。
>内部对象锁通过使用`Object`父类继承而来的`wait、notifyAll、notify``final`方法来实现`await`等方法。
内部锁存在一些限制：
1. 不能中断一个正在尝试获得锁的线程
2. 不能指定尝试获取锁的超时时间
3. 只有一个条件对象
#### 同步块
除了`synchronized`的方法可以获取内部锁，也可以使用同步块。
```java
//获取obj的内部锁
synchronized(obj){
	...
}
```
>注意：使用字符串字面量作为锁对象可能导致死锁，因为字符串字面量会共享
>另外，不要使用包装器对象作为锁
##### 客户端锁定
有时开发者使用一个对象的锁来实现额外的原子操作，这种做法称为**客户端锁定**。
在一个非同步方法中调用了同步方法，同步方法调用完成后线程可能被抢占导致出现竟态条件的问题。为此，在调用同步方法的代码块通过同步块来使用某个对象的同步锁。
>这个方法是可行的，但非常脆弱。这依赖于调用的同步方法使用的是内部锁，通常建议别用
##### volatile的字段
如果只是为了读写实例字段使用同步，所带来的开销不太划算。`volatile`关键字为实例字段的访问提供一种免锁机制。如果一个字段被声明为`volatile`的，那么编译器和虚拟机会考虑该字段可能被其他线程并发更新
>volatile不能提供原子性。例如：不能讲字段的值取反。无法保证读取、取反和写入不被中断。

#### 按需初始化
有时，对于某些东西，你可能希望在需要使用时进行初始化，并且只初始化一次。可以利用虚拟机在使用类时加载静态成员的机制，将需要的部分设置成静态代码块。
```java
class ClassName{
	...
	static K{
		static xxx = ...;
	}
}
```
#### 线程局部变量
有时需要在各个线程中各自提供实例以避免并发访问造成的破坏，可以使用`ThreadLocal`类来为每个线程在需要时才构造对应的实例。
```java
public static final ThreadLocal<Xxx> a = ThreadLocal.withInitial(() -> new Xxx());
Xxx b = a.get();
```
在某个线程中首次调用`get`方法时，会调用lambda表达式，在这之后调用的`get`方法会返回实例。
在多个线程中生产随机也存在类似的问题。`java.util.Random`类是线程安全的，但是如果多个线程等待一个共享的随机数生成器，效率很低。可以使用`ThreadLocal`辅助类为每个线程提供一个单独的生成器实例，不过Java7另外提供了一个方便的类。
`ThreadLocalRandom.current()`会返回当前线程的随机数生成器实例