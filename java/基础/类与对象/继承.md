```java
public class ClassName extends SuperClassName{}
```
>java语言规范指出，声明为`private`的成员不会被子类继承
>一个子类只能有一个父类，但是可以有多个接口

#### 覆盖方法
在子类中有时需要将继承来的方法覆盖，重新声明一个相同函数签名的函数会造成覆盖，而不同函数签名的同名函数是重载。
返回类型不是函数签名的一部分。但是在覆盖一个方法时，需要保证返回类型兼容。Java允许覆盖方法的返回类型是原方法的返回类型的子类型。
>为了避免由于函数签名导致的错误，可以在函数最前面添加`@Override`标记来避免该错误

>在覆盖一个方法时，子类方法的访问级别不能低于父类原方法的级别，例如原本是public，那新的方法也必须是public的
##### 调用被覆盖的方法
通过==super==关键字可以调用，如：`super.FuncName`
#### 调用父类的构造器
子类的构造器不能访问父类的私有字段，但是可以通过调用父类的构造器来初始化这些私有字段，进而通过父类提供的get来获取私有字段
`super()`
调用父类的构造器与调用该类的其他构造器类似，需要在第一行。
### 多态
在Java中，引用变量是多态的。一个父类类型的变量可以引用任何一个子类的对象，但是该变量只能调用父类有的成员。

通过多态可以给父类类型赋值子类对象。同时，这种方法当然是可逆的，通过强制类型转换可以复原，编译器将检查这次强制类型转换是否是一次“复原”。如果不是，将会抛出`ClassCastException`。
建议在强制转换类型之前，先检查能否成功，尽可能避免抛出错误。为此使用==instanceof操作符==来检查值的真实类型
##### instanceof模式匹配
```java
if(a instanceof Object){
	Object obj = (Object)a;
}
//简便写法
if(a instanceof Object obj){
//这种简便写法实质上就是检查值之后直接强制转换类型
	...
}
```

>当利用多态转换类型为父类时，如果调用的方法在子类中被覆盖，那么实际调用的方法将会是子类中定义的新方法，但这么做会降低可读性
## 阻止继承：final的类和方法
有时，开发者会希望某个类不能被继承，或者是某个方法不能被覆盖。使用`final`关键字就可以了。
```java
public final class ClassName{}
...
public final func(){}
```
>如果将一个类声明为`final`，只有其中的方法自动成为`final`的，不包括字段
## 密封类
密封类只能被指定的类继承，`final`的类阻止所有继承，而密封类阻止非法继承。
>java17中确定加入该特性
```java
public abstract sealed class ClassName
	permits ...
{
}
```
>声明指定子类可以不加permits子句，但是这样所有的子类必须在同一个文件中
密封类允许的子类有些限制：
1. 必须是可访问的，不能是其他包中的公共类
2. public的子类必须与密封类在同一个包中
3. 必须指定它是`sealed`、`final`、`non-sealed`的其中之一，`non-sealed`是允许派生
