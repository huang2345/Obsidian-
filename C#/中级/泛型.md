泛型允许我们声明**类型参数化**的代码，用不同的类型进行实例化。
C#提供了5种泛型：类、结构、接口、委托和方法。前四个都是类型，只有方法是成员
### 5种泛型
#### 泛型类
1. 使用占位符来表示未知的类型
2. 为占位符提供**真实类型**，该类型被称为**构造类型**
```c#
class myClass<T1,T2,...>{
	...
}
myClass a = new myClass<int,int,...>();
```
#### 泛型方法
泛型方法可以在泛型和非泛型类以及结构和接口中声明
```c#
public void xxx<T1,T2,...>(T1 xxx,...) where ...{}
```
调用泛型方法时提供类型实参：`xxx<int,int>()`，除此之外编译器还可以从方法参数的类型推断除类型参数的类型。
#### 泛型结构
```c#
struct xxx<T>{}
```
#### 泛型委托
泛型委托与泛型方法的语法类似
```c#
delegate R xxxx<T,R>(T value);
```
#### 泛型接口
```c#
interface xxx<T>{}
```
### 类型参数的约束
可以提供额外的信息让编译器知道参数可以接收哪些类型。这些额外的信息叫做**约束**
#### Where子句
约束使用where子句列出。
```C#
where 类型参数 : a,b,c,...
```
where子句可以以任何次序列出。但是where子句中的约束必须有特定的顺序。
- 只能有一个主约束：类名、class、struct
- 可以有多个接口名称约束
- 如果存在构造函数约束，必须在最后
##### 约束类型和次序

| 约束类型   | 描述                                  |
| ------ | ----------------------------------- |
| 类名     | 只有这个类或它的子类才能用作类型实参                  |
| class  | 任何引用类型                              |
| struct | 任何值类型                               |
| 接口名    | 只有这个接口或实现这个接口的类型                    |
| new()  | 任何带有无参公共构造函数的类型都可以用作类型实参。**构造函数约束** |
