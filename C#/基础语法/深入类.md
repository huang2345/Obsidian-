### 类成员
##### 实例类成员
普通成员
#### 静态字段
被类的所有实例共享且可通过类直接访问。
除去`类.静态字段`的访问，还可以使用`using static 命名空间.类`的方法去使用类中的静态字段
##### 生存周期
>如果静态字段有初始化语句，那么会在使用该类的任何静态成员之前初始化该字段，但不一定在程序执行开始就初始化
#### 静态函数成员
与静态字段有类似的生存周期和访问方法。
静态方法不能访问实例字段，只能访问静态字段
#### 成员常量
成员常量与静态字段类似，能以类似的方法访问
#### 抽象成员
是指设计为被覆写的函数成员。必须是一个函数成员，修饰符`abstract`
抽象成员只能在**抽象类**中声明，一共有四种类型的成员可以声明为抽象的：
- 方法
- 属性
- 事件
- 索引器

### 属性
属性是代表类实例或类中的数据项的成员，与字段类似，但它是一个函数成员。
属性本身没有任何存储，get/set访问器会决定如何处理数据。因此，属性常与字段关联，而与属性关联的字段常被称为**后备字段**或**后备存储**。

>属性有如下特征：
	1. 是命名的类成员，有类型并可以被赋值和读取
	2. 不一定为数据存储分配内存
	3. 它执行代码

属性是一组匹配的、命名的、称为==访问器==的方法。除了两个访问器，属性不允许拥有其他方法。
```c#
int attr{
	set{}
	get{}
}
```
#### 静态属性
属性也可以声明为`static`
#### get/set访问器
两个访问器至少要有一个
set访问器总是：
- 拥有一个单独的、隐式的值参value，与属性的类型相同
- 返回类型为void
get访问器总是：
- 无参
- 拥有一个与属性类型相同的返回类型

C#7.0为get/set访问器引入另一种语法，该语法使用lambda表达式：
```C#
int myTest{
	set => ...;
	get => ...;
}
```
#### 杂项
##### 属性与后备字段的命名约定
第一种：
字段使用Camel大小写，属性使用Pascal大小写
第二种：
字段使用_+Camel大小写，属性使用Pascal大小写
##### 自动实现属性
无后备字段并且不能提供访问器的方法体。从C#6.0开始可以使用。
```C#
public int attr{
	set;get;
}
```
### 构造函数
用于初始化类的实例的状态。
```
class testClass{
	public testClass(){}
}
```
##### 使用new运算符创建实例
###### 对象创建表达式
`new 类型(参数)`
##### 默认构造函数
如果在类的声明中没有显式的提供实例构造函数，那么编译器会提供一个隐式的默认构造函数。它没有参数并且方法体为空
#### 静态构造函数
构造函数也可以声明为`static`。实例构造函数初始化类的每个新实例，而`static`构造函数初始化类级别的项。通常，静态构造函数初始化类的静态字段。
- 类只能有一个静态构造函数，而且不能带参数，不能有访问修饰符
- 如同静态方法，静态构造函数不能访问所在类的实例成员，因此不能使用`this`访问器
- 不能在程序中显式调用静态构造函数，系统会自动调用
#### 析构函数
析构函数执行在类的实例被销毁之前需要的清理或释放非托管资源的行为。非托管资源是指通过win32 API获取的文件句柄或非托管内存块使用`.NET`资源是无法得到他们的
#### 对象初始化语句
对象创建表达式由关键字`new`和构造函数及其参数列表组成，**对象初始化语句**扩展了创建语法，在表达式尾部放置了一组**成员初始化语句**，使得可以在构造函数执行之后快速设置**可访问**的**字段**和**属性**的值
```C#
new TypeName {x=...,...}//如果要使用无参数列表的形式，类需要有无参的构造方法，会使用无参的构造方法
new TypeName(params) {...}
```
### 访问修饰符
#### 类访问修饰符
对类的可访问性只有`public`和`internal`
##### public(公有的)
可以被程序中的任何程序集中的其他对象访问
##### internal(内部的)
只能被所在的程序集内的类访问，类的默认可访问级别
#### 成员访问修饰符
成员的可访问性不能比它的类高
以下5个成员访问级别：
1. `public`
2. `private`
3. `protected`
4. `internal`
5. `protected internal`
##### private私有的(默认)
私有成员只能从声明它的类的内部访问。不能被其他类访问，包括派生类
##### protected受保护的
类似`private`，但可以被派生类访问
##### internal内部的
能被同一程序集访问
##### protected internal
能被派生类以及同一程序集中的类访问
### 索引器
一般访问实例的实例字段会使用点运算符和字段名，但是有时使用索引去访问会很方便。
索引器是一组get/set访问器，与属性相似。
```C#
//参数列表中至少有一个参数
//set和get访问器的参数列表与索引器相同
返回类型 this [参数列表]{
	set{...}
	get{...}
}
```
>可以认为**索引器**是为类的**多个数据成员**提供get和set访问的属性
注意事项：
	- 可以只有一个访问器
	- 总是实例成员，不能被声明为`static`
#### 索引器重载
需要索引器的参数列表不同
### 各种类
#### 抽象类
指设计为被继承的类，只能用作其他类的基类。不能创建抽象类的实例，修饰符==abstract==
可以包含非抽象成员。任何派生自抽象类的类必须用==override==关键字实现抽象成员
#### 密封类
==`sealed`==类不能用作基类，与抽象类相反。
#### 静态类
1. 所有成员都是静态的。
2. 可以有一个静态构造函数，但不能有实例构造函数
3. 隐式密封
### 其他
#### readonly修饰符
字段可以用`readonly`修饰符声明，其作用类似`const`。
区别：
- `readonly`字段可以在构造函数或声明语句中初始化。如果是`static`的，初始化必须在静态构造函数中完成
- `readonly`字段的值可以在运行时决定
#### this关键字
`this`关键字在类中使用，是对当前实例的引用。他只能被用在下列类成员的代码块中：
- 实例构造函数
- 实例方法
- 属性和索引器的实例访问器
因为静态成员不是实例的一部分，所以不能在任何静态函数成员的代码中使用`this`关键字
#### 访问器的访问修饰符
默认情况下，成员的两个访问器的访问级别和成员自身相同。但是可以手动设置访问器的访问修饰符，但是有以下限制：
1. 只有两个访问器set/get都存在时，才可以有访问修饰符
2. get/set访问器之间，只能有一个有访问修饰符
3. 访问器的访问修饰符必须比成员的访问级别更严格
#### 分部类
可以将类的声明分割成多份，可以在不同文件中，但组成类的所有分部类必须一起编译
```c#
partial class testClass{
	...
}
...
partial class testClass{
	...
}
```
##### 分部方法
分部方法是在分部类中分割方法的定义和实现部分。
```c#
//定义部分
partial void testFunc(params);
//实现部分
partial void testFunc(params){
	...
}
```
1. 定义部分和实现部分的签名和返回类型必须匹配
2. 返回类型必须是`void`
3. 签名不能包括访问修饰符，分部方法是**隐式私有**的
4. 参数列表不能包含`out`参数
#### 扩展方法
允许在不修改类的情况下，增加类的方法。
1. 声明扩展方法的类必须声明为`static`
2. 扩展方法本身必须声明为`static`和`public`
3. 扩展方法必须包含关键字`this`作为它的第一个参数类型，并在后面跟着它扩展的类的名称
```C#
static class xxx{
	public static xxx func(this XXX a)
	{...}
}
```