如果直接在 DOM 中书写模板 (例如原生 `<template>` 元素的内容)，模板的编译需要遵从浏览器中 HTML 的解析行为。在这种情况下，你应该需要使用 `kebab-case` 形式并显式地关闭这些组件的标签。
```
<!-- 如果是在 DOM 中书写该模板 -->
<button-counter></button-counter>
<button-counter></button-counter>
<button-counter></button-counter>
```

#### 传递 props
通过在子组件上使用`defineProps`宏来设置接收的数据

`defineProps` 是一个仅 `<script setup>` 中可用的编译宏命令，并不需要显式地导入。声明的 props 会自动暴露给模板。`defineProps` 会返回一个对象，其中包含了可以传递给组件的所有 props：
```
const props = defineProps(['title'])
```

当一个 prop 被注册后，可以在父组件中以属性的形式将值传递给子组件

#### 监听事件

子组件可以通过调用内置的 [**`$emit`** 方法](https://cn.vuejs.org/api/component-instance.html#emit)，通过传入事件名称来抛出一个事件。
然后在父组件中监听这个事件来响应事件的触发。

可以通过 [`defineEmits`](https://cn.vuejs.org/api/sfc-script-setup.html#defineprops-defineemits) 宏来声明需要抛出的事件，这可以让 Vue 避免将它们作为原生事件监听器隐式地应用于子组件的根元素。

### 通过插槽来分配内容[​](https://cn.vuejs.org/guide/essentials/component-basics.html#content-distribution-with-slots)

向组件中传递内容文本
```
//渲染组件，nnn为插入文本
<xxx>nnnnn</xxx>

//在组件中用<slot>标签接收内容
```

#### 动态组件
通过`<component>` 元素和特殊的 `is` attribute

`:is` 的值可以是以下几种：
- 被注册的组件名
- 导入的组件对象
你也可以使用 `is` attribute 来创建一般的 HTML 元素。

当使用 `<component :is="...">` 来在多个组件间作切换时，被切换掉的组件会被卸载。我们可以通过 [`<KeepAlive>` 组件](https://cn.vuejs.org/guide/built-ins/keep-alive.html)强制被切换掉的组件仍然保持“存活”的状态。

##### 元素位置限制[​](https://cn.vuejs.org/guide/essentials/component-basics.html#element-placement-restrictions)

某些 HTML 元素对于放在其中的元素类型有限制，例如 `<ul>`，`<ol>`，`<table>` 和 `<select>`，相应的，某些元素仅在放置于特定元素中时才会显示，例如 `<li>`，`<tr>` 和 `<option>`。

这将导致在使用带有此类限制元素的组件时出现问题。例如：
```
<table>
  <blog-post-row></blog-post-row>
</table>
```

自定义的组件 `<blog-post-row>` 将作为无效的内容被忽略，因而在最终呈现的输出中造成错误。我们可以使用特殊的 [`is` attribute](https://cn.vuejs.org/api/built-in-special-attributes.html#is) 作为一种解决方案：
```
<table>
  <tr is="vue:blog-post-row"></tr>
</table>
```
当使用在原生 HTML 元素上时，`is` 的值必须加上前缀 `vue:` 才可以被解析为一个 Vue 组件。这一点是必要的，为了避免和原生的[自定义内置元素](https://html.spec.whatwg.org/multipage/custom-elements.html#custom-elements-customized-builtin-example)相混淆。