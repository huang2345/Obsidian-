响应式是`vue`同步变量数据的基础，`vue`有两种声明响应式的方法。
1. 使用`ref()`包裹
2. 使用`reactive()`包裹对象
### ref()
`ref()`接受参数，并将其包裹在一个带有`value`属性的`ref`对象中。
要在组件模板中访问，需要从组件的`setup()`函数中声明并返回。
```js
import { ref } from 'vue'
export default {
  // `setup` 是一个特殊的钩子，专门用于组合式 API。
  setup() {
    const count = ref(0)
    // 将 ref 暴露给模板
    return {
      count
    }
  }
}
```
>在模板中使用`ref`时会自动解包。
#### `<script setup>`
在set up函数中手动暴露大量的状态和方法非常繁琐。可以通过在单文件组件中使用`<script setup>`来简化代码。
`<script setup>`中的顶层的变量和函数可以在同一组件的模板中直接使用。
#### 为什么使用响应式的变量
使用响应式的变量是为了在变量更新时同步更新DOM，为了利用`vue`的响应式系统。
当一个组件首次渲染时，`vue`会追踪在渲染过程中使用的每一个`ref`，当一个`ref`被修改时，它会触发追踪它的组件的一次重新渲染
#### 深层响应性
`ref`可以持有任何类型的值。`ref`是它的值具有深层响应性，即：改变对象的内部属性时，同样被检测到。因为内部属性被转为响应式的。
非基本类型的值将通过`reactive()`转换为响应式代理。
可以通过`shallowRef()`来放弃深层响应式，用`shallowRef`可以避免对多余的大型数据的响应性开销来优化性能。
#### DOM更新时机
当你修改了响应式的变量，DOM会自动更新。但DOM更新不是同步的，`vue`会在`next tick`更新周期中缓冲所有状态的修改，以确保无论进行多少次修改每个组件只更新一次。
可以通过`nextTick()`全局API，在DOM更新后执行额外的代码。
### reactive()
与将值包装在特殊对象中的`ref`不同，该方法将使对象本身具有响应性：
```js
let count = reaactive({count: 0});
```
响应式对象是JS代理，其行为与普通对象一样。不同的是`vue`能够拦截对响应式对象所有属性的访问和修改，以便进行依赖追踪和触发更新。
该方法返回的响应式对象同样拥有深层响应性。与浅层`ref`类似，也有一个`shallowReactive()`API可以选择放弃深层响应性。
#### 代理对象
`reactive`返回的是一个原始对象的代理，它与原始对象是不相等的。只有代理对象是响应式的，更改原始对象不会触发更新。
为了保证代理的一致性，对同一个原始对象调用`reactive`总是返回相同的代理对象。而对一个已存在的代理对象调用`reactive`会返回它自己。
依靠深层响应性，响应式对象内的嵌套对象依旧是代理。
#### reactive的局限性
1. 有限的值类型，不能使用基础类型
2. 不能替换整个对象