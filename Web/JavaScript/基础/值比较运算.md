1. `===` 严格相等
2. `==` 宽松相等
3. `Object.is()`

#### 严格相等
比较两个值，被比较的值在比较前都不进行隐式转换。
#### 宽松相等
1. 
	- Object
		仅当两个操作数引用相同的对象，返回true
	- String
		仅当两个操作数的每一个字符都相同时，返回true
	- Number
		仅当两个操作数具有相同的值时，，返回true。+0和-0被视为相同的值
	- Boolean
		比较布尔值
	- BigInt
		仅当两个操作数具有相同的值时，才返回 true
	- Symbol
		仅当两个操作数引用相同的Symbol时，返回true
2. 如果操作数之一为 `null` 或 `undefined` ，则另一个操作数必须为 `null` 或 `undefined` 才能返回true
3. 如果操作数之一是对象，另一个是原始值，则将对象转换为原始值

一般而言，根据 `ECMAScript` 规范，所有原始类型和对象都不与 undefined 和 null 宽松相等。但是大部分浏览器允许非常有限的一类对象（即，所有页面中的 document.all 对象）在某些情况下表现出模拟 undefined 值特性。宽松相等就是这些情况之一：当且仅当 A 是一个模拟 undefined 的对象时，null == A 和 undefined == A 将会计算得到 true。在其他所有情况下，一个对象都不会与 undefined 或 null 宽松相等。

> 在大多数情况下，不建议使用宽松相等。使用严格相等进行比较的结果更容易预测，并且由于缺少类型强制转换可以更快地执行。

#### 使用Object.is()
比较两个参数。

Object.is() 与 == 运算符并不等价。== 运算符在测试相等性之前，会对两个操作数进行类型转换（如果它们不是相同的类型），这可能会导致一些非预期的行为，例如 "" == false 的结果是 true，但是 Object.is() 不会对其操作数进行类型转换。

Object.is() 也不等价于 === 运算符。Object.is() 和 === 之间的唯一区别在于它们处理带符号的 0 和 NaN 值的时候。=== 运算符（和 == 运算符）将数值 -0 和 +0 视为相等，但是会将 NaN 视为彼此不相等。在Object.is()中，会将NaN视为彼此相等