HTTP 缓存会存储与请求关联的响应，并将存储的响应复用于后续请求。

当响应可复用时，源服务器不需要处理请求——因为它不需要解析和路由请求、根据 cookie 恢复会话、查询数据库以获取结果或渲染模板引擎。这减少了服务器上的负载。
### 不同种类的缓存
在 [HTTP Caching](https://httpwg.org/specs/rfc9111.html) 标准中，有两种不同类型的缓存：**私有缓存**和**共享缓存**。
#### 私有缓存
绑定到特定客户端的缓存——通常是浏览器缓存。由于存储的响应不与其他客户端共享，因此私有缓存可以存储该用户的个性化响应。
如果响应包含个性化内容并且你只想将响应存储在私有缓存中，则必须指定 `private` 指令。
```http
Cache-Control: private
```
>如果响应具有 `Authorization` 标头，则不能将其存储在私有缓存（或共享缓存，除非 Cache-Control 指定的是 `public`）中。

#### 共享缓存
共享缓存位于客户端和服务器之间，可以存储能在用户之间共享的响应。共享缓存可以进一步细分为**代理缓存**和**托管缓存**。
##### 代理缓存
除了访问控制的功能外，一些代理还实现了缓存以减少网络流量。
>现在不太能用了，随着HTTPS的普及，客户端/服务器通信变得加密，在大部分情况下，路径中的代理缓存只能传输响应而无法充当缓存
>TLS桥接代理通过在 PC 上安装来自组织管理的 [CA](https://developer.mozilla.org/zh-CN/docs/Glossary/Certificate_authority) 证书，以中间人方式解密所有通信，并执行访问控制等，则可以查看响应的内容并将其缓存。这种方法应用于企业策略。

##### 托管缓存
托管缓存由服务开发人员明确部署，以降低源服务器负载并有效地交付内容。(反向代理、CDN 和 service worker 与缓存 API 的组合)
托管缓存的特性因部署的产品而异。在大多数情况下，你可以通过 **`Cache-Control` 标头**和**配置文件**或**仪表板**来控制缓存的行为。

例如，HTTP 缓存规范本质上没有定义显式删除缓存的方法——但是使用托管缓存，可以通过仪表板操作、API 调用、重新启动等实时删除已经存储的响应。这允许更主动的缓存策略。

也可以忽略标准 HTTP 缓存规范协议以支持显式操作。
例如，可以指定以下内容以选择退出私有缓存或代理缓存，同时使用你自己的策略仅在托管缓存中进行缓存。
```HTTP
Cache-Control: no-store
```
#### 启发式缓存
HTTP旨在尽可能多地缓存，即使没有设置Cache-Control，如果满足某些条件，响应也会被存储和重用。这称为**启发式缓存**。
启发式缓存是在 `Cache-Control` 被广泛采用之前出现的一种解决方法，基本上所有响应都应明确指定 `Cache-Control` 标头。
#### 基于age的缓存策略
存储的HTTP响应有两种状态：==fresh==和==stale==。
- fresh表示响应有效
- stale表示缓存的响应已过期
确定这两种状态的标准是**age**。在 HTTP 中，age 是自响应生成以来经过的时间。
#### Vary响应
区分响应的方式本质上是基于URL：
但是同一URL的响应的内容可能不同，来自服务器的响应可能取决于 `Accept`、`Accept-Language` 和 `Accept-Encoding` 请求标头的值。
例如，对于带有 `Accept-Language: en` 标头并已缓存的英语内容，不希望再对具有 `Accept-Language: ja` 请求标头的请求重用该缓存响应。在这种情况下，你可以通过在 `Vary` 标头的值中添加“`Accept-Language`”，根据语言单独缓存响应。
#### 验证响应
过时的响应不会立刻被丢弃。HTTP可以通过询问源服务器将过时的响应转换为新的响应。这称为**验证**，或者说**重新验证**。
验证是通过使用包含`If-Modified-Since`或`If-None-Match`请求标头的条件请求完成的。
##### If-Modified-Since
当响应过时并不能复用时，客户端发送带有`If-Modified-Since`请求标头的请求，以询问服务器自指定时间以来被请求资源是否有改变。
如果没有改变，服务器将返回一个状态码为`304`的无body的响应表示没有变化。
如果有改变，服务器将在响应的body中包含新的资源，正常返回时状态码为`200`。

服务器可以从操作系统的文件系统中获取修改时间。但是，也存在一些问题，例如，时间格式复杂且难以解析，分布式服务器难以同步文件更新时间。
为了解决这些问题，`ETag`响应标头被标准化作为替代方案。
##### ETag/If-None-Match
`ETag`响应标头的值是服务器生成的任意值。
如果响应过时，客户端会获取缓存的响应的`ETag`值，并将对服务器发起一个带有`If-None-Match`请求标头的请求，以询问服务器资源是否被修改。

如果请求的资源的`ETag`标头与请求的`If-None-Match`标头相同，服务器会返回一个`304`状态码的响应表示资源未修改。
如果请求的资源与`If-None-Match`标头不匹配，则服务器会在响应的body中包含最新的资源。
>`If-None-Match`标头的值是客户端缓存的响应的`ETag`值。
>使用`ETag`+`If-None-Match`与`If-Modified-Since`相比，前者的精度更高，可以准确识别资源的版本前后；后者使用`Last-Modified`标头中的时间，优先级低于前者，但是可以询问资源自某一时间开始有没有被修改过(前者通过`ETag`版本号，后者通过服务器的文件中标注的修改时间)
##### 强制重新验证
如果始终从服务器获取最新内容，可以使用`Cache-Control:no-cache`标头来强制验证。
使用`no-cache`指令强制客户端每次使用缓存前都会对服务器发起验证请求，而验证通过`Last-Modified`和`ETag`等进行。
#### 不使用缓存
`Cache-Control`标头的`no-cache`指令不会阻止缓存响应，而是而是阻止在没有重新验证的情况下重用响应。
如果不希望缓存响应，应使用`Cache-Control`标头的`no-store`指令

不使用缓存的原因很多，但使用`no-store`指令并不是最优解
##### 不与其他用户共享
在这种情况下，使用`Cache-Control`标头的`private`指令使个性化响应只会在特定客户端缓存
##### 每次都提供最新的内容
`no-store`指令阻止存储响应，但不会删除相同`URL`的任何已存储响应。
如果已经为特定`URL`存储了旧响应，`no-store`不会阻止旧响应被重用。
#### 重新加载和强制重新加载
对请求和响应执行验证。
**重新加载**和**强制重新加载**操作是从浏览器端执行验证的常见示例。
##### 重新加载
为了从页面错误中恢复或更新到最新版本的资源，浏览器为用户提供了重新加载功能。
在浏览器重新加载期间发送的HTTP请求会设置`Cache-Control:max-age=0`，使该请求立即过时，然后通过`If-None-Match`或`If-Modified-Since`进行验证，以确保使用的响应是最新的

该行为也在[Fetch标准](https://fetch.spec.whatwg.org/#http-network-or-cache-fetch)中定义，并且可以通过在缓存模式(`cache`标头)设置为`no-cache`的情况下，在JS中调用fetch()来重现
```JS
fetch("/", { cache: "no-cache" });
```
>注意`reload`不是这种情况下的正确模式
##### 强制重新加载
>出于向后兼容的原因，浏览器在重新加载期间使用`max-age=0`,因为在 HTTP/1.1 之前的许多过时的实现中不理解`no-cache`。
强制重新加载是绕过缓存响应的另一种方法。

浏览器强制重新加载期间的HTTP请求如下所示：
```HTTP
GET / HTTP/1.1
Host: example.com
Pragma: no-cache
Cache-Control: no-cache
```
由于这不是带有`no-cache`的条件请求，因此可以确定会从源服务器获得`200 OK`。
该行为也在[Fetch标准](https://fetch.spec.whatwg.org/#http-network-or-cache-fetch)中定义，并且可以通过在缓存模式(`cache`标头)设置为`reload`的情况下，在JS中调用fetch()来重现
```JS
fetch("/", { cache: "reload" });
```
##### 避免重新验证
长时间不会更改的内容的`max-age`标头的值应该非常大。方法是使用缓存破环——也就是说，在请求URL中包含资源信息。
但是，当用户重新加载时，即使服务器知道内容是不可变的，也会发送重新验证请求。
`Cache-Control`标头的`immutable`指令可用于明确指示不需要重新验证。
>注意，[Chrome 已更改其实现](https://blog.chromium.org/2017/01/reload-reloaded-faster-and-leaner-page_26.html)，因此重新验证不会在重新加载子资源期间执行。

#### 删除存储的响应
基本上没有方法删除被缓存并且有很长的`max-age`的响应。
一旦资源在服务器上过期，大部分用户会希望获取最新的资源，但是由于缓存的旧资源的响应还没有过期，所以用户在一些缓存策略的影响下没有更新成最新的资源。

规范中提到的方法之一是使用不安全的方法（例如 POST）发送对同一 URL 的请求，但对于许多客户端而言，通常很难故意这样做。
还有一个 `Clear-Site-Data: cache` 标头和值的规范，但[并非所有浏览器都支持它](https://groups.google.com/a/mozilla.org/g/dev-platform/c/I939w1yrTp4)——即使使用它，它也只会影响浏览器缓存，而不会影响中间缓存。
缓存减少了对服务器的访问，这意味着服务器失去了对该 URL 的控制。如果服务器不想失去对URL的控制，应该为资源的`Cache-Control`标头添加`no-cache`指令。
#### 请求折叠
共享缓存主要位于源服务器之前，旨在减少到源服务器的流量。
因此，如果多个相同的请求同时到达共享缓存，共享缓存服务器会自己请求源服务器(将单个请求转发到源)。然后源服务器将响应发送给共享缓存，共享缓存服务器再将收到的缓存发送给客户端。

>当请求同时到达时会发生请求折叠，因此即使响应中给出了 `max-age=0` 或 `no-cache`，它也会被重用。
![](Pasted%20image%2020240915235156.png)
